@inject StateContainer stateContainer
@inject IConfiguration render

@if (fn?.IDNr == stateContainer.selectedFn)
{
    foreach (Coupling couplingS in stateContainer.couplingList.FindAll(x => x.outputFn == fn.IDNr || x.toFn == fn.IDNr))
    {
        <path fill="none" stroke-width="5" stroke=@render["fnStyle"+fn.fnStyle+":Properties:selected-fill"] stroke-linecap="round" opacity="0.5" d=@couplingS.reDrawLines(fn.IDNr,fn.x,fn.y) />
        <g transform="scale(@(stateContainer.tempZoomA))" display="@stateContainer.AspectLabelsDisplay">
            <rect x=@(couplingS.labelX - couplingS.Twidth / 2) y=@couplingS.labelY width=@couplingS.Twidth height=@(Math.Min(5 + couplingS.displayText.Count * 8, 50)) style="fill: #FFFFFF; stroke: none; opacity: 0.6" rx="5" ry="5" />
            <text transform="translate(0,-2)" x=@couplingS.labelX y=@(couplingS.labelY + 3) font-size="5pt" text-anchor="middle" font-family="'PT Sans Caption', sans-serif">
                @for (int i = 0; i < couplingS.displayText.Count; i++)
                {
                    <tspan x=@couplingS.labelX dy="8">@couplingS.displayText[i]</tspan>
                }
            </text>
        </g>
    }
}
<g class=@fnClass transform="translate(@fn?.x,@fn?.y)" @onmousedown="SelectFn" @ontouchstart="SelectFnTouch" @onmousemove="MoveFn" @ontouchmove="MoveFnTouch" @onmouseup="MoveFnStop" @ontouchend="MoveFnStopTouch">
    @if (fn?.IDNr == stateContainer.selectedFn)
    {
        if (dragFn)
        {
            <circle cx="50" cy="50" fill="white" opacity="0" r="100%" /> //this increases the size of the function during dragging so we don't lose the mouse pointer
        }
        <circle cx="50" cy="50" r=@render["fnStyle"+fn.fnStyle+":Properties:highlight-r"] fill="url(#fnSelected)" />
        //} else if (selectedGroup[0]==sFn) { //set background highlight colour
        // svgXML.g.(@id==sFn).appendChild(<circle cx="50" cy="50" r="60" fill="url(#00F2FF)" />);
        //} else if (checkGroup.indexOf("|"+sFn+"|")>-1){
        // svgXML.g.(@id==sFn).appendChild(<circle cx="50" cy="50" r="60" fill="url(#11FF55)" />);
        //} else if (functionArray[sFn].HLColor!=null) {
        //   svgText = "url(#" + functionArray[sFn].HLColor + ")";
        //   svgXML.g.(@id==sFn).appendChild(<circle cx="50" cy="50" r="60" fill={svgText} />);
    }
    @if (fn?.orphans > 0)
    {
        if (((fn.orphans >> 0) & 1) == 1) //Input
        {
            <circle stroke-width="5" stroke="#FF0000" fill="none" opacity="0.7" cx="6" cy="50" r="7" />
        }
            if (((fn.orphans >> 1) & 1) == 1) //Output
        {
            <circle stroke-width="5" stroke="#FF0000" fill="none" opacity="0.7" cx="93.5" cy="50" r="7" />
        }
            if (((fn.orphans >> 2) & 1) == 1) //Precondition
        {
            <circle stroke-width="5" stroke="#FF0000" fill="none" opacity="0.7" cx="28" cy="88" r="7" />
        }
            if (((fn.orphans >> 3) & 1) == 1) //Resource
        {
            <circle stroke-width="5" stroke="#FF0000" fill="none" opacity="0.7" cx="71.5" cy="88" r="7" />
        }
            if (((fn.orphans >> 4) & 1) == 1) //Control
        {
            <circle stroke-width="5" stroke="#FF0000" fill="none" opacity="0.7" cx="71.5" cy="12" r="7" />
        }
            if (((fn.orphans >> 5) & 1) == 1) //Time
        {
            <circle stroke-width="5" stroke="#FF0000" fill="none" opacity="0.7" cx="28" cy="12" r="7" />
        }
    }
    <!-- This is the Function main outline -->
    <g stroke-width=@render[fn?.options+"fn-stroke-width"] stroke=@render[fn?.options+"fn-stroke"]>
        <path d=@render[fn?.options+"fn-connector-path"] />
        <path fill=@render[fn?.options+"fn-fill"] fill-opacity=@render[fn?.options+"fn-opacity"] d=@render[fn?.options+"fn-path"] />
    </g>
    @if (fn?.fnColorStyle != null)
    {
        if (fn.fnColorStyle.Length != 0)
        {
            isFnColor = true;
            styleStroke = render[fn.options+"fn-color-width"];
            switch (fn.fnColorStyle)
            {
                case "blue": styleColor = "#01A6DB"; break;
                case "green": styleColor = "#17BD01"; break;
                case "grey": styleColor = "#838383"; break;
                case "red": styleColor = "#E50000"; break;
                case "yellow": styleColor = "#BAB727"; break;
                case "purple": styleColor = "#9070C0"; break;
                case "white": styleColor = "#FFFFFF"; break;
                case "custom": styleColor = "#" + "000000".Substring(Convert.ToUInt32(fn.fnColorValue).ToString("X").Length) + Convert.ToUInt32(fn.fnColorValue).ToString("X"); break;
                default: styleColor = render[fn.options+"aspect-stroke"]; styleStroke = render[fn.options+"aspect-stroke-width"]; break;
            }
            <g>
                <g stroke-width=@styleStroke stroke=@styleColor>
                    <path fill="none" d=@render[fn.options+"fn-color-path"] />
                </g>
                <g stroke-width=@render[fn.options+"fn-stroke-width"] stroke=@render[fn.options+"fn-stroke"]>
                    <path fill="none" d=@render[fn.options+"fn-path"] />
                </g>
            </g>
        }
        else
        {
            isFnColor = false;
        }
    }
    else
    {
        isFnColor = false;
    }
    <g stroke-width=@render[fn?.options+"aspect-stroke-width"] stroke=@render[fn?.options+"aspect-stroke"]>
        <circle cx=@render["fnStyle"+fn?.fnStyle+":aspectX:I"] cy=@render["fnStyle"+fn?.fnStyle+":aspectY:I"] r=@render[fn?.options+"aspect-r"] fill=@render[fn?.options+"aspect-fill"] />
        <circle cx=@render["fnStyle"+fn?.fnStyle+":aspectX:O"] cy=@render["fnStyle"+fn?.fnStyle+":aspectY:O"] r=@render[fn?.options+"aspect-r"] fill=@render[fn?.options+"aspect-fill"] />
        <circle cx=@render["fnStyle"+fn?.fnStyle+":aspectX:T"] cy=@render["fnStyle"+fn?.fnStyle+":aspectY:T"] r=@render[fn?.options+"aspect-r"] fill=@render[fn?.options+"aspect-fill"] />
        <circle cx=@render["fnStyle"+fn?.fnStyle+":aspectX:C"] cy=@render["fnStyle"+fn?.fnStyle+":aspectY:C"] r=@render[fn?.options+"aspect-r"] fill=@render[fn?.options+"aspect-fill"] />
        <circle cx=@render["fnStyle"+fn?.fnStyle+":aspectX:P"] cy=@render["fnStyle"+fn?.fnStyle+":aspectY:P"] r=@render[fn?.options+"aspect-r"] fill=@render[fn?.options+"aspect-fill"] />
        <circle cx=@render["fnStyle"+fn?.fnStyle+":aspectX:R"] cy=@render["fnStyle"+fn?.fnStyle+":aspectY:R"] r=@render[fn?.options+"aspect-r"] fill=@render[fn?.options+"aspect-fill"] />
    </g>

    @if (fn?.FunctionType == "1") //variable foreground
    {
        <g stroke="#BBBBBB"><path fill="none" d="M 30 50 Q 35 30 40 30 Q 45 30 50 50 Q 55 70 60 70 Q 65 70 70 50" /></g>
    }
    @if (@render[fn?.options+"fn-path"] == "") //modern background
    {
        if (!isFnColor)
        {
            styleStroke = @render[fn?.options+"aspect-alt-stroke-width"];
            styleColor = @render[fn?.options+"aspect-alt-stroke"];
        }
        string isIO;
        double fontAdjustX;
        double fontAdjustY = 2.8 - (6 - double.Parse(render[fn?.options + "aspect-font-size"])) / 2;
        if (fn?.isInput == "true")
        {
            isIO = "I";
            fontAdjustX = -1.8 + (6 - double.Parse(render[fn.options + "aspect-font-size"])) / 2;
        } else
        {
            isIO = "O";
            fontAdjustX = -3.1 + (6 - double.Parse(render[fn?.options + "aspect-font-size"])) / 2;
        }
        <g stroke-width=@styleStroke stroke=@styleColor>
            <circle cx=@render["fnStyle"+fn?.fnStyle+":aspectX:"+isIO] cy=@render["fnStyle"+fn?.fnStyle+":aspectY:"+isIO] r=@render[fn?.options+"aspect-r"] fill=@render[fn?.options+"aspect-alt-fill"] />
        </g>
        <g font-size="@(render[fn?.options+"aspect-font-size"]+"pt")" font-family="'PT Sans Caption', sans-serif" fill=@render[fn?.options+"aspect-font-color"]>
            <text x=@(double.Parse(render["fnStyle"+fn?.fnStyle+":aspectX:"+isIO])+fontAdjustX) y=@(double.Parse(render["fnStyle"+fn?.fnStyle+":aspectY:"+isIO])+fontAdjustY)>@isIO</text>
        </g>
        <rect transform="scale(@stateContainer.tempZoomF)" x="@(50 / stateContainer.tempZoomF - 36)" y="@(50 / stateContainer.tempZoomF - fn?.displayText.Count * 5 - 5)"
          rx=@render[fn?.options+"fn-alt-r"] ry=@render[fn?.options+"fn-alt-r"] width=@render[fn?.options+"fn-alt-width"] height="@(9 + fn?.displayText.Count * 10)" fill=@render[fn?.options+"fn-alt-fill"] style="stroke:none;opacity:1" />
    }
    else //y+2.8 xI-1.8 xO-3.1 xT-2.6 xC-3.1 xP-2.4 xR-2.7 // 6pt=2.8, 4pt=
    {
        double fontAdjust = (6 - double.Parse(render[fn?.options+"aspect-font-size"])) / 2;
        <g font-size="@(render[fn?.options+"aspect-font-size"]+"pt")" font-family="'PT Sans Caption', sans-serif" fill=@render[fn?.options+"aspect-font-color"]>
            <text x=@(double.Parse(render["fnStyle"+fn?.fnStyle+":aspectX:T"])-2.6+fontAdjust) y=@(double.Parse(render["fnStyle"+fn?.fnStyle+":aspectY:T"])+2.8-fontAdjust)>T</text>
            <text x=@(double.Parse(render["fnStyle"+fn?.fnStyle+":aspectX:C"])-3.1+fontAdjust) y=@(double.Parse(render["fnStyle"+fn?.fnStyle+":aspectY:C"])+2.8-fontAdjust)>C</text>
            <text x=@(double.Parse(render["fnStyle"+fn?.fnStyle+":aspectX:I"])-1.8+fontAdjust) y=@(double.Parse(render["fnStyle"+fn?.fnStyle+":aspectY:I"])+2.8-fontAdjust)>I</text>
            <text x=@(double.Parse(render["fnStyle"+fn?.fnStyle+":aspectX:O"])-3.1+fontAdjust) y=@(double.Parse(render["fnStyle"+fn?.fnStyle+":aspectY:O"])+2.8-fontAdjust)>O</text>
            <text x=@(double.Parse(render["fnStyle"+fn?.fnStyle+":aspectX:P"])-2.4+fontAdjust) y=@(double.Parse(render["fnStyle"+fn?.fnStyle+":aspectY:P"])+2.8-fontAdjust)>P</text>
            <text x=@(double.Parse(render["fnStyle"+fn?.fnStyle+":aspectX:R"])-2.7+fontAdjust) y=@(double.Parse(render["fnStyle"+fn?.fnStyle+":aspectY:R"])+2.8-fontAdjust)>R</text>
        </g>
    }
    <text transform="scale(@stateContainer.tempZoomF)" x="@(50 / stateContainer.tempZoomF)" y="@(50 / stateContainer.tempZoomF - fn?.displayText.Count * 5 - 3)"
          font-size="6pt" text-anchor="middle" width="60" height="40" font-family="'PT Sans Caption', sans-serif" fill=@render[fn?.options+"fn-font-color"]>
    @for (int i = 0; i < fn?.displayText.Count; i++)
    {
        <tspan x="@(50 / stateContainer.tempZoomF)" dy="10">@fn.displayText[i]</tspan>
    }
    </text>
</g>

@code {
    private Dictionary<string, double> posX = new Dictionary<string, double> { { "I", 6 }, { "O", 93.5 }, { "T", 28 }, { "C", 71.5 }, { "P", 28 }, { "R", 71.5 } };
    private Dictionary<string, double> posY = new Dictionary<string, double> { { "I", 50 }, { "O", 50 }, { "T", 12 }, { "C", 12 }, { "P", 88 }, { "R", 88 } };
    private string styleStroke = "1";
    private string styleColor = "#999999";
    private bool isFnColor = false;
    private bool dragFn = false;
    private string fnClass = "fn-hover";

    [Parameter]
    public Function? fn { get; set; }
    [Parameter]
    public EventCallback refreshParent { get; set; }

    private void SelectFnTouch(TouchEventArgs e)
    {
        if (e.Touches.Length == 1)
        {
            if (stateContainer.selectedFn != "-1" && stateContainer.functionList.Find(x => x.IDNr == stateContainer.selectedFn)?.label == "")
            {
                stateContainer.defaultFnLabel();
            }
            stateContainer.selectedLabel = "";
            stateContainer.selectedFn = fn?.IDNr??"-1";
            stateContainer.fnName = stateContainer.functionList.Find(x => x.IDNr == stateContainer.selectedFn)?.label??"";
            stateContainer.isDisabled = false;
            refreshParent.InvokeAsync();
            stateContainer.startX = e.Touches[0].ClientX / stateContainer.scaleZoom - fn?.x??0;
            stateContainer.startY = e.Touches[0].ClientY / stateContainer.scaleZoom - fn?.y??0;
            dragFn = true;
            fnClass = "fn-move";
            // ? touchAction = "touch-stop";
        }
    }
    private void SelectFn(MouseEventArgs e)
    {
        if (stateContainer.selectedFn != "-1" && stateContainer.functionList.Find(x => x.IDNr == stateContainer.selectedFn)?.label == "")
        {
            stateContainer.defaultFnLabel();
        }
        stateContainer.selectedLabel = "";
        stateContainer.selectedFn = fn?.IDNr??"-1";
        stateContainer.fnName = stateContainer.functionList.Find(x => x.IDNr == stateContainer.selectedFn)?.label??"";
        stateContainer.isDisabled = false;
        refreshParent.InvokeAsync();
        stateContainer.startX = e.ClientX / stateContainer.scaleZoom - fn?.x ?? 0;
        stateContainer.startY = e.ClientY / stateContainer.scaleZoom - fn?.y ?? 0;
        dragFn = true;
        fnClass = "fn-move";
    }
    private void MoveFnTouch(TouchEventArgs e)
    {
        if (dragFn && e.Touches.Length == 1 && fn!=null)
        {
            fn.x = (e.Touches[0].ClientX / stateContainer.scaleZoom - stateContainer.startX);
            fn.y = (e.Touches[0].ClientY / stateContainer.scaleZoom - stateContainer.startY);
            if (fn.x > stateContainer.viewWidth - 120)
            {
                stateContainer.viewWidth += 120;
                stateContainer.canvasWidth = stateContainer.viewWidth * stateContainer.scaleZoom;
                refreshParent.InvokeAsync();
            }
            if (fn.y > stateContainer.viewHeight - 120)
            {
                stateContainer.viewHeight += 120;
                stateContainer.canvasHeight = stateContainer.viewHeight * stateContainer.scaleZoom;
                refreshParent.InvokeAsync();
            }
        }
        //        else if (dragAspect)
        //        {
        //
        //        }
    }
    private void MoveFn(MouseEventArgs e)
    {
        if (dragFn && fn != null)
        {
            fn.x = (e.ClientX / stateContainer.scaleZoom - stateContainer.startX);
            fn.y = (e.ClientY / stateContainer.scaleZoom - stateContainer.startY);
            if (fn.x > stateContainer.viewWidth - 120)
            {
                stateContainer.viewWidth += 120;
                stateContainer.canvasWidth = stateContainer.viewWidth * stateContainer.scaleZoom;
                refreshParent.InvokeAsync();
            }
            if (fn.y > stateContainer.viewHeight - 120)
            {
                stateContainer.viewHeight += 120;
                stateContainer.canvasHeight = stateContainer.viewHeight * stateContainer.scaleZoom;
                refreshParent.InvokeAsync();
            }
        }
        //       else if (dragAspect)
        //       {
        //
        //       }
    }
    private void MoveFnStopTouch(TouchEventArgs e)
    {
        if (dragFn && fn != null)
        {
            if (stateContainer.couplingList.Count > 0)
            {
                foreach (Coupling couplingS in stateContainer.couplingList.FindAll(x => x.outputFn == fn.IDNr || x.toFn == fn.IDNr))
                {
                    stateContainer.projectData_Undo[0].SelectSingleNode("//FM/Aspects/Aspect[Name=\"" + couplingS.Name + "\"]/Curve2")!.InnerText = couplingS.curve2;
                    stateContainer.projectData_Undo[0].SelectSingleNode("//FM/Aspects/Aspect[Name=\"" + couplingS.Name + "\"]/Curve")!.InnerText = couplingS.curve;
                }
            }
            dragFn = false;
            //            dragAspect = false;
            fnClass = "fn-hover";
            stateContainer.updateXY(fn.x, fn.y);
            // ? touchAction = "";
        }
    }
    private void MoveFnStop(MouseEventArgs e)
    {
        if (dragFn && fn != null)
        {
            if (stateContainer.couplingList.Count > 0)
            {
                foreach (Coupling couplingS in stateContainer.couplingList.FindAll(x => x.outputFn == fn.IDNr || x.toFn == fn.IDNr))
                {
                    stateContainer.projectData_Undo[0].SelectSingleNode("//FM/Aspects/Aspect[Name=\"" + couplingS.Name + "\"]/Curve2")!.InnerText = couplingS.curve2;
                    stateContainer.projectData_Undo[0].SelectSingleNode("//FM/Aspects/Aspect[Name=\"" + couplingS.Name + "\"]/Curve")!.InnerText = couplingS.curve;
                }
            }
            dragFn = false;
            //            dragAspect = false;
            fnClass = "fn-hover";
            stateContainer.updateXY(fn.x, fn.y);
        }
    }
}
